<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>T-TDM test</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
#menu {
position: absolute;
background: #efefef;
padding: 10px;
font-family: 'Open Sans', sans-serif;
font-size: 16px;
width: 250px;
}

#info {
position: absolute;
background: #efefef;
padding: 10px;
font-family: 'Open Sans', sans-serif;
font-size: 16px;
width: 250px;
}

.mapboxgl-popup {
max-width: 300px;
background: #efefef;
font-family: 'Open Sans', sans-serif;
font-size: 16px;
}

.mapboxgl-popup-content {
  background-color: #efefef;
}

.map-overlay {
font: 20px/30px 'Helvetica Neue', Arial, Helvetica, sans-serif;
position: absolute;
width: 300px;
top: 0;
left: 0;
padding: 10px;
}
 
.map-overlay .map-overlay-inner {
background-color: #fff;
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
border-radius: 3px;
padding: 10px;
margin-bottom: 10px;
}
 
.map-overlay-inner fieldset {
border: none;
padding: 0;
margin: 0 0 10px;
}
 
.map-overlay-inner fieldset:last-child {
margin: 0;
}
 
.map-overlay-inner select,
.map-overlay-inner input {
width: 100%;
}
 
.map-overlay-inner label {
display: block;
font-weight: bold;
margin: 0 0 5px;
}

.legend {
background-color: #fff;
border-radius: 3px;
top: 30px;
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
font: 20px/25px 'Helvetica Neue', Arial, Helvetica, sans-serif;
padding: 10px;
position: absolute;
right: 10px;
z-index: 1;
}
 
.legend h4 {
margin: 0 0 10px;
}
 
.legend div span {
border-radius: 50%;
display: inline-block;
height: 20px;
margin-right: 5px;
width: 20px;
}

.box {
  margin-left: 5px;
  display: inline-block;
  height: 20px;
  width: 20px;
  border: 1px solid;
}

.scrollbar {
  width: 230px;
  height: 300px;
  background: #efefef;
  overflow-y: scroll;
  font-family: 'Open Sans', sans-serif;
  font-size: 16px;
}

.force-overflow {
  min-height: 450px;
}

.scrollbar-primary::-webkit-scrollbar {
  width: 12px;
  background-color: #F5F5F5;
}

.scrollbar-primary::-webkit-scrollbar-thumb {
  border-radius: 10px;
  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.1);
  background-color: #4285F4;
}

.scrollbar-primary {
  scrollbar-color: #4285F4 #F5F5F5;
}
</style>
</head>
<body>
    <div id="state-legend" class="legend">
        <h4>Population</h4>
        <div><span style="background-color: #723122"></span>25,000,000</div>
        <div><span style="background-color: #8b4225"></span>10,000,000</div>
        <div><span style="background-color: #a25626"></span>7,500,000</div>
        <div><span style="background-color: #b86b25"></span>5,000,000</div>
        <div><span style="background-color: #ca8323"></span>2,500,000</div>
        <div><span style="background-color: #da9c20"></span>1,000,000</div>
        <div><span style="background-color: #e6b71e"></span>750,000</div>
        <div><span style="background-color: #eed322"></span>500,000</div>
        <div><span style="background-color: #f2f12d"></span>0</div>
        </div>
         
        <div id="county-legend" class="legend" style="display: none">
        <h4>Population</h4>
        <div><span style="background-color: #723122"></span>1,000,000</div>
        <div><span style="background-color: #8b4225"></span>500,000</div>
        <div><span style="background-color: #a25626"></span>100,000</div>
        <div><span style="background-color: #b86b25"></span>50,000</div>
        <div><span style="background-color: #ca8323"></span>10,000</div>
        <div><span style="background-color: #da9c20"></span>5,000</div>
        <div><span style="background-color: #e6b71e"></span>1,000</div>
        <div><span style="background-color: #eed322"></span>100</div>
        <div><span style="background-color: #f2f12d"></span>0</div>
        </div>
<div id="map"></div>
<div class="map-overlay top">
    <div id="menu">
        <!-- See a list of Mapbox-hosted public styles at -->
        <!-- https://docs.mapbox.com/api/maps/styles/#mapbox-styles -->
        <input id="light-v10" type="radio" name="rtoggle" value="light" checked="checked">
        <label for="light-v10">light</label><br>
        <input id="satellite-v9" type="radio" name="rtoggle" value="satellite">
        <label for="satellite-v9">satellite</label><br>
        <input id="dark-v10" type="radio" name="rtoggle" value="dark">
        <label for="dark-v10">dark</label><br>
        <input id="streets-v11" type="radio" name="rtoggle" value="streets">
        <label for="streets-v11">streets</label><br>
        <input id="outdoors-v11" type="radio" name="rtoggle" value="outdoors">
        <label for="outdoors-v11">outdoors</label><br>
        <input id="terrain" type="radio" name="rtoggle" value="outdoors">
        <label for="terrain">terrain</label><br>
        <!-- <button id="test">rb</button><br>
        <button id="test1">rg</button><br> -->
        <div id="info">
            <div><strong>VectexId:</strong> <span id='VectexId'></span></div>
            <div><strong>Lat:</strong> <span id='Latitude'></span></div>
            <div><strong>Lon:</strong> <span id='Longitude'></span></div>
            <div><strong>Color alpha:</strong> <span id='Color_alpha'></span></div>
            <br>
            <div><strong>cfh height:</strong> <span id='height'></span></div>
            <div><strong>cfh binaryStr:</strong> <span id='binaryStr'></span></div>
            <div><strong>cfh featureStr:</strong> <span id='featureStr'></span></div>
            <div><strong>cfh change threshold:</strong> <span id='threshold'></span></div>
            <br>
            <div><strong>tdm color:</strong> <span id='tdm_color'></span><div class="box" id="tdm_color_sample" style="background-color: #723122"></div></div>
            <div><strong>tdm lambda max:</strong> <span id='tdm_lambda_max'></span></div>
            <div><strong>tdm lambda min:</strong> <span id='tdm_lambda_min'></span></div>
            <div><strong>tdm lambda:</strong> <span id='tdm_lambda'></span></div>
            <div><strong>access time (s):</strong> <span id='access_time'></span></div>
            <div><strong>ift cost (E dis^2):</strong> <span id='ift_cost'></span></div>
            <div><strong>tdm cost (m):</strong> <span id='tdm_cost'></span></div>
            <div class="scrollbar scrollbar-primary">
                <div class="force-overflow"><div><strong>cfh matrix:</strong> <span id='cfh_matrix'></span></div>
                </div>
            </div>
        </div>
        
    </div>
    
    
    <!-- <fieldset class="conic-param-input">
    <label>Center Longitude: <span id="lng-value">0</span></label>
    <input id="lng" type="range" min="-180" max="180" step="any" value="0">
    </fieldset>
    <fieldset class="conic-param-input">
    <label>Center Latitude: <span id="lat-value">30</span></label>
    <input id="lat" type="range" min="-90" max="90" step="any" value="30">
    </fieldset>
    <fieldset class="conic-param-input">
    <label>Southern Parallel Lat: <span id="lat1-value">30</span></label>
    <input id="lat1" type="range" min="-90" max="90" step="any" value="30">
    </fieldset>
    <fieldset class="conic-param-input">
    <label>Northern Parallel Lat: <span id="lat2-value">30</span></label>
    <input id="lat2" type="range" min="-90" max="90" step="any" value="30">
    </fieldset> -->
</div>
<script>
    async function abc()
    {
        const response = await fetch(
            'polygon.geojson'
            );
        rawdata = await response.json();
        console.log(rawdata)
    }
    
    let hoveredStateId = null;
    
    a = false;
    b = false;
   
    featureStr = "01";
    Threshold = 0.0002;

    const markerHeight = 50;
    const markerRadius = 10;
    const linearOffset = 25;
    const popupOffsets = {
    'top': [0, 0],
    'top-left': [0, 0],
    'top-right': [0, 0],
    'bottom': [0, -markerHeight],
    'bottom-left': [linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
    'bottom-right': [-linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
    'left': [markerRadius, (markerHeight - markerRadius) * -1],
    'right': [-markerRadius, (markerHeight - markerRadius) * -1]
    };

    abc()

	mapboxgl.accessToken = 'pk.eyJ1IjoiZmVsYW5kbyIsImEiOiJjbDI0dHJ4cHIyMzhmM2lscHBiZ2VybWl0In0.O46bIQ6f08o0E55XLhESZg';
    styleStr = 'mapbox://styles/mapbox/light-v10';
    map = new mapboxgl.Map({
        style: styleStr, 
    //style: 'mapbox://styles/mapbox/light-v10',
    //style: 'mapbox://styles/mapbox/streets-v11',
    //style: 'mapbox://styles/mapbox-map-design/ckhqrf2tz0dt119ny6azh975y',
    center: [6.1645443, 62.4720013],
    zoom: 16,
    pitch: 0,
    bearing: 0,
    container: 'map',
    antialias: true
    });
    loadBasicLayger();

    layerId = "light-v10";
    labelLayerId = 0;

    radarData =  {
    'type': 'image',
    'url': 'https://docs.mapbox.com/mapbox-gl-js/assets/radar.gif',
    'coordinates': [
    [6.1589338, 62.4723013],
    [6.1644474, 62.47264497],
    [6.165792, 62.471144],
    [6.1596182, 62.4714755]
    ]
    }

pointlist = {
    'type': 'FeatureCollection',
    'features': [
    {
    // H1， 278087398，62.4723013,6.1589338
    'type': 'Feature',
    'geometry': {
    'type': 'Point',
    'coordinates': [
    6.1589338, 62.4723013
    ]
    },
    'properties': {
    'title': 'H1',
    'color': "blue"
    }
    },
    {
    // H2，7204337168,62.4726449,6.1644474
    'type': 'Feature',
    'geometry': {
    'type': 'Point',
    'coordinates': [
    6.1644474, 62.4726449
    ]
    },
    'properties': {
    'title': 'H2',
    'color': "red"
    }
    },
    {
    // H3，8714559173,62.4714755,6.1596182
    'type': 'Feature',
    'geometry': {
    'type': 'Point',
    'coordinates': [
    6.1596182, 62.4714755
    ]
    },
    'properties': {
    'title': 'H3',
    'color': "green"
    }
    },
    {
    // H4, 7379970801,62.471144,6.165792
    'type': 'Feature',
    'geometry': {
    'type': 'Point',
    'coordinates': [
    6.165792, 62.471144
    ]
    },
    'properties': {
    'title': 'H4',
    'color': "purple"
    }
    }
    ]
    }


function ComputeCFH(Matrix, featureStr, Threshold)
{
    if(Matrix.length >= featureStr.length)
    { 
        let binaryStr = "";
        for(i = 0; i < 4; i++)//Matrix.length - 1
        {
            if(Math.abs(Matrix[i+1] - Matrix[i]) >= Threshold)
            {
                console.log(Math.abs(Matrix[i+1] - Matrix[i]));
                binaryStr +="1";
            }
            else
                binaryStr +="0";
        }
        console.log(binaryStr)
        return [binaryStr, binaryStr.split(featureStr).length - 1];
    }
    else
        return ["", 0]
}

function loadBasicLayger()
{
    map.on('style.load', (e) => {
// Insert the layer beneath any symbol layer.
// if(layerId != "satellite-v9")
// {
//     const layers = map.getStyle().layers;
//     labelLayerId = layers.find(
//     (layer) => layer.type === 'symbol' && layer.layout['text-field']
//     ).id;
//     //console.log(layers)
//     //console.log(labelLayerId)
// }

// map.addSource('mapbox-dem', {
// 'type': 'raster-dem',
// 'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
// 'tileSize': 512,
// 'maxzoom': 14
// });
// // add the DEM source as a terrain layer with exaggerated height
// map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });
 
// // add a sky layer that will show when the map is highly pitched
// map.addLayer({
// 'id': 'sky',
// 'type': 'sky',
// 'paint': {
// 'sky-type': 'atmosphere',
// 'sky-atmosphere-sun': [0.0, 0.0],
// 'sky-atmosphere-sun-intensity': 15
// }
// });

// if(layerId != "satellite-v9")
// {
// // The 'building' layer in the Mapbox Streets
// // vector tileset contains building height data
// // from OpenStreetMap.
// map.addLayer(
// {
// 'id': 'add-3d-buildings',
// 'source': 'composite',
// 'source-layer': 'building',
// 'filter': ['==', 'extrude', 'true'],
// 'type': 'fill-extrusion',
// 'minzoom': 15,
// 'paint': {
// 'fill-extrusion-color': '#aaa',
 
// // Use an 'interpolate' expression to
// // add a smooth transition effect to
// // the buildings as the user zooms in.
// 'fill-extrusion-height': [
// 'interpolate',
// ['linear'],
// ['zoom'],
// 15,
// 0,
// 15.05,
// ['get', 'height']
// ],
// 'fill-extrusion-base': [
// 'interpolate',
// ['linear'],
// ['zoom'],
// 15,
// 0,
// 15.05,
// ['get', 'min_height']
// ],
// 'fill-extrusion-opacity': 0.6
// }
// },
// labelLayerId
// );
// }
// Create a default Marker and add it to the map.
const marker1 = new mapboxgl.Marker({color:"blue"})
.setLngLat([6.1589338, 62.4723013])
.addTo(map);

const marker2 = new mapboxgl.Marker({color:"red"})
.setLngLat([6.1644474, 62.4726449])
.addTo(map);

const marker3 = new mapboxgl.Marker({color:"green"})
.setLngLat([6.1596182, 62.4714755])
.addTo(map);

const marker4 = new mapboxgl.Marker({color:"purple"})
.setLngLat([6.165792, 62.471144])
.addTo(map);

    map.addSource('states', {
    'type': 'geojson',
    'data': 'polygon.geojson'//'https://docs.mapbox.com/mapbox-gl-js/assets/us_states.geojson'
    });

    // Add an image to use as a custom marker
    map.loadImage(
    'https://docs.mapbox.com/mapbox-gl-js/assets/custom_marker.png',
    (error, image) => {
    if (error) throw error;
    map.addImage('custom-marker', image);
    // Add a GeoJSON source with 4 points
    map.addSource('points', {
    'type': 'geojson',
    'data': pointlist});


    // map.addSource('radar', radarData);
    // map.addLayer({
    // id: 'radar-layer',
    // 'type': 'raster',
    // 'source': 'radar',
    // 'paint': {
    // 'raster-fade-duration': 0
    // }
    // });

    // map.addSource('polygon1', {
    // type: 'geojson',
    // // Use a URL for the value for the `data` property.
    // data: rawdata,//'polygon.geojson',
    // });
    // // Add a new layer to visualize the polygon.
    // map.addLayer({
    // 'id': 'poly1',
    // 'type': 'fill',
    // 'source': 'polygon1', // reference the data source
    // 'layout': {},
    // 'paint': {
    // 'fill-color': '#00ff00', // blue color fill
    // 'fill-opacity': 1.0
    // }
    // });

    // Add a data source containing GeoJSON data.
    map.addSource('maine', {
    'type': 'geojson',
    'data': {
    'type': 'Feature',
    'id': 1,
    'geometry': {
    'type': 'Polygon',
    // These coordinates outline Maine.
    'coordinates': [
    [
    [6.1589338, 62.4723013],
    [6.1644474, 62.47264497],
    [6.165792, 62.471144],
    [6.1596182, 62.4714755],
    [6.1589338, 62.4723013],
    ]
    ]
    }
    }
    });
    // Add a new layer to visualize the polygon.
    map.addLayer({
    'id': 'maine',
    'type': 'fill',
    'source': 'maine', // reference the data source
    'layout': {},
    'paint': {
    'fill-color': '#0080ff', // blue color fill
    'fill-opacity': [
            'case',
            ['boolean', ['feature-state', 'hover'], false],
            1,
            0
            ]
    }
    });

    // Add a data source containing GeoJSON data.
    map.addSource('road1', {
    'type': 'geojson',
    lineMetrics: true,
    'data': {
    'type': 'Feature',
    'geometry': {
    'type': 'LineString',
    // These coordinates outline Maine.
    'coordinates': [
    [
    [6.1589338, 62.4723013],
    [6.16444, 62.47264497],
    [6.165792, 62.471144],
    [6.1596182, 62.4714755],
    ]
    ]
    }
    }
    });
// 'line-gradient' can only be used with GeoJSON sources
// and the source must have the 'lineMetrics' option set to true
map.addSource('line', {
type: 'geojson',
lineMetrics: true,
data: geojson
});
 
// // the layer must be of type 'line'
// map.addLayer({
// type: 'line',
// source: 'line',
// id: 'line',
// paint: {
// 'line-color': 'red',
// 'line-width': 10,
// 'line-width': 20,
// "line-dasharray": [2, 4]
// }
// });
    }
);
const geojson = {
'type': 'FeatureCollection',
'features': [
{
'type': 'Feature',
'properties': {},
'geometry': {
'coordinates': [
    [6.1589338, 62.4723013],
    [6.16444, 62.47264497],
    [6.165792, 62.471144],
    [6.1596182, 62.4714755],
],
'type': 'LineString'
}
}
]
};
//stores = map.queryRenderedFeatures({ layers: ['road1'] })
//console.log(stores)
// if(map.isSourceLoaded("polygon1")){
//         const stores = map.querySourceFeatures("polygon1")
//         console.log(stores)
//     }
});
    map.on('sourcedata', (e) => {
        //console.log(e)
        if(!a && e.sourceId === "points" && map.isSourceLoaded("points")){
            //console.log("abc")
            pointlist.features[0].properties.title = "H101";
            console.log(pointlist)
            map.getSource('points').setData(pointlist);
            // Add a symbol layer
            map.addSource('polygon1', {
            type: 'geojson',
            // Use a URL for the value for the `data` property.
            data: rawdata,//'polygon.geojson',
            });
            
            // Add a symbol layer
            map.addLayer({
            'id': 'points',
            'type': 'symbol',
            'source': 'points',
            'layout': {
            //'icon-image': 'custom-marker',
            // get the title name from the source's "title" property
            'text-field': ['get', 'title'],
            'text-font': [
            'Open Sans Semibold',
            'Arial Unicode MS Bold'
            ],
            'text-offset': [0, -3.5],
            'text-anchor': 'top',
            },
            'paint': {
                'text-color': ['get', 'color'],
            },
            });

            map.addLayer({
                'id': 'room-extrusion',
                'type': 'fill-extrusion',
                'source': 'polygon1',
                'paint': {
                // Get the `fill-extrusion-color` from the source `color` property.
                //'fill-extrusion-color': ['get', 'color'],
                'fill-extrusion-color':[
                    'case',
                    ['boolean', ['feature-state', 'hover'], false],
                    "green",
                    "grey"
                    ],//"grey",
                
                // Get `fill-extrusion-height` from the source `height` property.
                'fill-extrusion-height': ['get', 'height'],
                
                // Get `fill-extrusion-base` from the source `base_height` property.
                //'fill-extrusion-base': ['get', 'base_height'],
                
                // Make extrusions slightly opaque to see through indoor walls.
                'fill-extrusion-opacity': 0.6
                }
                });

            a = true;
        }
    })

    // after load the polygon raw data file, add layers
    map.on('sourcedata', (e) => {
        //console.log(e)
        if(!b && e.sourceId === "polygon1" && map.isSourceLoaded("polygon1")){
            //console.log("abc")
            //console.log(rawdata.features.length)
            //console.log(rawdata.features[0].properties.name)

            i = rawdata.features.length - 1;
            lambda_min = rawdata.features[i].properties.tdm_lambda_min;
            lambda_max = rawdata.features[i].properties.tdm_lambda_max;

            dtdm_lambda_min.textContent = parseFloat(lambda_min.toFixed(6));
            dtdm_lambda_max.textContent = parseFloat(lambda_max.toFixed(6));

            dfeatureStr.textContent = featureStr;
            dthreshold.textContent = Threshold;

            console.log(rawdata.features.length)

            for(i=0; i<rawdata.features.length-1;i++)//rawdata.features.length-1
            {
                //console.log("abc")
                props = rawdata.features[i].properties;
                props.color = props.tdm_color;
                // color mapping with lambda value
                props.alpha = 1 - (props.tdm_lambda - lambda_min) / (lambda_max - lambda_min);
                matrix = props.cfh_matrix;

                // console.log(matrix)
                // if (i < 3)
                // {
                //     console.log("i_" + i)
                //     ComputeCFH([79.77503, 79.770546, 79.76627, 79.76627, 79.76889, 79.77992, 79.77701, 79.77503, 79.77433, 79.77361, 79.76804, 79.7653656, 79.7584839, 79.7584839, 79.7584839, 79.7584839, 79.7644348, 79.76154, 79.7584839, 79.770546], "01", 0.0002);
                //     //cfhresult = ComputeCFH(matrix, "01", 0.2);
                //     //console.log(cfhresult)
                // }
                if(matrix.length >= featureStr.length)
                { 
                    let binaryStr = "";
                    for(j = 0; j < matrix.length - 1; j++)//Matrix.length - 1
                    {
                        //console.log(Math.abs(matrix[j+1] - matrix[j]));
                        if(Math.abs(matrix[j+1] - matrix[j]) >= Threshold)
                        {
                            binaryStr +="1";
                        }
                        else
                            binaryStr +="0";
                    }
                    //console.log(binaryStr)
                    //console.log( binaryStr.split(featureStr).length - 1)
                    props.cfh_bstr = binaryStr;
                    props.height = (binaryStr.split(featureStr).length - 1);
                }
                else
                {
                    props.cfh_bstr = "";
                    props.height = 0;
                }

                // height = 0;
                // for(j = 0; j < matrix.length; j++)
                //     height += matrix[j];
                // props.height = height / matrix.length;
            }

            // cfhresult = ComputeCFH([79.77503, 79.770546, 79.76627, 79.76627, 79.76889, 79.77992, 79.77701, 79.77503, 79.77433, 79.77361, 79.76804, 79.7653656, 79.7584839, 79.7584839, 79.7584839, 79.7584839, 79.7644348, 79.76154, 79.7584839, 79.770546], "01", 0.0002);
            // console.log(cfhresult)

            map.getSource('polygon1').setData(rawdata);
            console.log(rawdata)

            addLayers_Hover();

            // Add a new layer to visualize the polygon.
            map.addLayer({
                'id': 'poly1',
                'type': 'fill',
                'source': 'polygon1', // reference the data source
                'layout': {},
                'paint': {
                'fill-color': ['get', 'color'],//'#00ff00', // blue color fill
                'fill-opacity': ['get', 'alpha']
                }
            });

            b = true;
        }
    })

    // When a click event occurs on a feature in the states layer,
    // open a popup at the location of the click, with description
    // HTML from the click event's properties.
    map.on('click', 'poly1', (e) => {
        //console.log(123)
    new mapboxgl.Popup()//({className:"popstyle"})
    .setLngLat(e.lngLat)
    .setHTML(infoList.innerHTML)//e.features[0].properties.cfh + "," + e.features[0].properties.name + "," + e.lngLat)
    .addTo(map);

    //console.log(infoList.outerHTML)
    });

    activeHover();
}

function addLayers_Hover()
{
    // add black outline
    map.addLayer({
        'id': 'outline',
        'type': 'line',
        'source': 'polygon1',
        'layout': {},
        'paint': {
        'line-width': [
        'case',
        ['boolean', ['feature-state', 'hover'], false],
        4,
        0
        ],
        'line-color': 'black'
        }
    });

    // add transparent fill to capture the hover area
    // The feature-state dependent fill-opacity expression will render the hover effect
    // when a feature's hover state is set to true.
    map.addLayer({
        'id': 'state-fills',
        'type': 'fill',
        'source': 'polygon1',
        'layout': {},
        'paint': {
        'fill-color': 'black',
        'fill-opacity': [
        'case',
        ['boolean', ['feature-state', 'hover'], false],
        0,
        0
        ]
        }
    });
}

function activeHover()
{
    // Change the cursor to a pointer when
    // the mouse is over the states layer.
    map.on('mouseenter', 'poly1', () => {
    map.getCanvas().style.cursor = 'pointer';
    });
    
    // Change the cursor back to a pointer
    // when it leaves the states layer.
    map.on('mouseleave', 'poly1', () => {
    map.getCanvas().style.cursor = '';
    });
    
    // When the user moves their mouse over the state-fill layer, we'll update the
    // feature state for the feature under the mouse.
    map.on('mousemove', 'state-fills', (e) => {
    if (e.features.length > 0) {
    if (hoveredStateId !== null) {
    map.setFeatureState(
    { source: 'polygon1', id: hoveredStateId },
    { hover: false }
    );
    }
    hoveredStateId = e.features[0].id;
    map.setFeatureState(
    { source: 'polygon1', id: hoveredStateId },
    { hover: true }
    );
    dVectexId.textContent = hoveredStateId;
    dLatitude.textContent = e.lngLat.lng;
    dLongitude.textContent = e.lngLat.lat;

    props = e.features[0].properties;
    dColor_alpha.textContent = parseFloat(props.alpha.toFixed(6));
    dtdm_color.textContent = props.color;
    dtdm_color_sample.style.backgroundColor = props.color;
    dtdm_lambda.textContent = parseFloat(props.tdm_lambda.toFixed(6));
    daccess_time.textContent = parseFloat(props.tdm_accesstime.toFixed(6));
    dift_cost.textContent = parseFloat(props.ift_cost.toFixed(6));
    dtdm_cost.textContent = parseFloat(props.tdm_cost.toFixed(6));
    dheight.textContent = parseFloat(props.height.toFixed(6));
    dbinaryStr.textContent = chunkString(props.cfh_bstr, 10);
    dcfh_matrix.textContent = props.cfh_matrix.toString().split(',').join(',\n');
    //console.log(hoveredStateId + ":true");
    }
    });
    
    // When the mouse leaves the state-fill layer, update the feature state of the
    // previously hovered feature.
    map.on('mouseleave', 'state-fills', (e) => {
    if (hoveredStateId !== null) {
        //console.log(hoveredStateId + ":false");
    map.setFeatureState(
    { source: 'polygon1', id: hoveredStateId },
    { hover: false }
    );
    dVectexId.textContent = "No data";;
    dLatitude.textContent = "No data";
    dLongitude.textContent = "No data";
    dColor_alpha.textContent = "No data";
    dtdm_color.textContent = "No data";
    dtdm_color_sample.style.backgroundColor = "white";
    dtdm_lambda.textContent = "No data";
    daccess_time.textContent = "No data";
    dift_cost.textContent = "No data";
    dtdm_cost.textContent = "No data";
    }
    hoveredStateId = null;
    });
}

function chunkString(str, length) {
  return str.match(new RegExp('.{1,' + length + '}', 'g')).join('\n');
}

function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

//const map;
function loadMap()
{
    loadBasicLayger();

}

const mapStyleInput = document.getElementById('mapStyle');

const layerList = document.getElementById('menu');
const infoList = document.getElementById('info');
const inputs = layerList.getElementsByTagName('input');

const testbutton = document.getElementById('test');
const testbutton1 = document.getElementById('test1');

const dVectexId = document.getElementById('VectexId');
const dLatitude = document.getElementById('Latitude');
const dLongitude = document.getElementById('Longitude');
const dColor_alpha = document.getElementById('Color_alpha');

const dtdm_color = document.getElementById('tdm_color');
const dtdm_color_sample = document.getElementById('tdm_color_sample');
const dtdm_lambda_max = document.getElementById('tdm_lambda_max');
const dtdm_lambda_min = document.getElementById('tdm_lambda_min');
const dtdm_lambda = document.getElementById('tdm_lambda');
const daccess_time = document.getElementById('access_time');
const dift_cost = document.getElementById('ift_cost');
const dtdm_cost = document.getElementById('tdm_cost');

const dheight = document.getElementById('height');
const dthreshold = document.getElementById('threshold');
const dbinaryStr = document.getElementById('binaryStr');
const dfeatureStr = document.getElementById('featureStr');
const dcfh_matrix = document.getElementById('cfh_matrix');


for (const input of inputs) {
    input.onclick = (layer) => {
        layerId = layer.target.id;
        console.log(layerId);
        if(layerId == "terrain")
        {
            map.setStyle('mapbox://styles/mapbox-map-design/ckhqrf2tz0dt119ny6azh975y');
            //loadBasicLayger();
        }
        else
            map.setStyle('mapbox://styles/mapbox/' + layerId); 
        a = false;
        b = false;
    };
}

// testbutton.onclick = () => {
//         radarData =  {
//         'type': 'image',
//         'url': 'ImplementationUI.jpg',
//         'coordinates': [
//         [6.1589338, 62.4723013],
//         [6.1644474, 62.47264497],
//         [6.165792, 62.471144],
//         [6.1596182, 62.4714755]
//         ]
//         }
//         //console.log(radarData);
//         map.getSource('radar').updateImage(radarData);

//         for(i=0; i<rawdata.features.length-1;i++)
//             {
//                 rd = rawdata.features[i];
//                 console.log(rawdata.features[i].properties.name)
//                 rawdata.features[i].properties.color = rgbToHex(i*10,0,255-i*10)
//                 // if(rawdata.features[i].properties.name == "i3j3")
//                 //     rawdata.features[i].properties.color = "red";
//                 // else
//                 //     rawdata.features[i].properties.color = "blue";
//             }
            


//             map.getSource('polygon1').setData(rawdata);
//     };

//     testbutton1.onclick = () => {
//         for(i=0; i<rawdata.features.length-1;i++)
//             {
//                 rd = rawdata.features[i];
//                 console.log(rawdata.features[i].properties.name)
//                 rawdata.features[i].properties.color = rgbToHex(i*10,255-i*10,0)
//                 // if(rawdata.features[i].properties.name == "i3j3")
//                 //     rawdata.features[i].properties.color = "red";
//                 // else
//                 //     rawdata.features[i].properties.color = "blue";
//             }
            


//             map.getSource('polygon1').setData(rawdata);
//     };

</script>
 
</body>
</html>