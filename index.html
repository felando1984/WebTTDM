<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>T-TDM test</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous"> -->
<link href="index.css" rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

<script src="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.js"></script>
<script src="https://code.highcharts.com/highcharts.js"></script>
<script src="https://code.highcharts.com/modules/series-label.js"></script>
<script src="https://code.highcharts.com/modules/exporting.js"></script>
<script src="https://code.highcharts.com/modules/export-data.js"></script>
<script src="https://code.highcharts.com/modules/accessibility.js"></script>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<style>

</style>
</head>
<body>
    
    <div id="graph2d" class="legend">
         <!-- <h4>Population</h4>
        <div><span style="background-color: #723122"></span>25,000,000</div>
        <div><span style="background-color: #8b4225"></span>10,000,000</div>
        <div><span style="background-color: #a25626"></span>7,500,000</div>
        <div><span style="background-color: #b86b25"></span>5,000,000</div>
        <div><span style="background-color: #ca8323"></span>2,500,000</div>
        <div><span style="background-color: #da9c20"></span>1,000,000</div>
        <div><span style="background-color: #e6b71e"></span>750,000</div>
        <div><span style="background-color: #eed322"></span>500,000</div>
        <div><span style="background-color: #f2f12d"></span>0</div>
        </div>
         
        <div id="county-legend" class="legend" style="display: none">
        <h4>Population</h4>
        <div><span style="background-color: #723122"></span>1,000,000</div>
        <div><span style="background-color: #8b4225"></span>500,000</div>
        <div><span style="background-color: #a25626"></span>100,000</div>
        <div><span style="background-color: #b86b25"></span>50,000</div>
        <div><span style="background-color: #ca8323"></span>10,000</div>
        <div><span style="background-color: #da9c20"></span>5,000</div>
        <div><span style="background-color: #e6b71e"></span>1,000</div>
        <div><span style="background-color: #eed322"></span>100</div>
        <div><span style="background-color: #f2f12d"></span>0</div> -->
            <div class="dropdown">
              <input type="button" class="btn btn-primary" id="btn_LoadData" value="RefreshData"/>
              <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuBtnStyle" data-bs-toggle="dropdown" aria-expanded="false">
               Chart Style
              </button>
              <ul class="dropdown-menu dropdown-menu-dark" aria-labelledby="dropdownMenuBtnStyle">
                <li id="option1"><a class="dropdown-item" href="#">line</a></li>
                <li id="option2"><a class="dropdown-item" href="#">area</a></li>
                <li id="option3"><a class="dropdown-item" href="#">column</a></li>
                <li id="option4"><a class="dropdown-item" href="#">bar</a></li>
              </ul>
            </div>
            
            <figure class="highcharts-figure">
                <div id="container"></div>
                <div style="float:left" class="btn-group" role="group" aria-label="data_filter_type">
                    <input type="radio" class="btn-check" name="btnradio1" id="btnradio_Daily" autocomplete="off" checked>
                    <label class="btn btn-outline-primary" for="btnradio_Daily">Daily</label>
                  
                    <input type="radio" class="btn-check" name="btnradio1" id="btnradio_Cumu" autocomplete="off">
                    <label class="btn btn-outline-primary" for="btnradio_Cumu">Cumulative</label>
                  </div>
            
                <div style="float:right" class="btn-group" role="group" aria-label="data_source_type">
                    <input type="radio" class="btn-check" name="btnradio2" id="btnradio_Tested" autocomplete="off" checked>
                    <label class="btn btn-outline-primary" for="btnradio_Tested">Covid tests</label>
                  
                    <input type="radio" class="btn-check" name="btnradio2" id="btnradio_Infected" autocomplete="off">
                    <label class="btn btn-outline-primary" for="btnradio_Infected">Infected cases</label>
            
                    <input type="radio" class="btn-check" name="btnradio2" id="btnradio_Death" autocomplete="off">
                    <label class="btn btn-outline-primary" for="btnradio_Death">Covid deaths</label>
                  </div>
            </figure>
    </div>
<div id="map"></div>

<div class="map-overlay top hidden">
    
    <div class="map-overlay-inner">
        <h4>&nbsp&nbsp&nbsp&nbspT-TDM Graph4</h4>

        <ul class="nav nav-pills mb-3" id="pills-tab" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="pills-home-tab" data-bs-toggle="pill" data-bs-target="#pills-home" type="button" role="tab" aria-controls="pills-home" aria-selected="true">Load</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="pills-profile-tab" data-bs-toggle="pill" data-bs-target="#pills-profile" type="button" role="tab" aria-controls="pills-profile" aria-selected="false">Layers</button>
            </li>
          </ul>
          <div class="tab-content" id="pills-tabContent">
            <div class="tab-pane fade show active" id="pills-home" role="tabpanel" aria-labelledby="pills-home-tab">
                <input type="file" class="form-control" name="file" id="file"><button class="btn btn-primary" onclick="doupload()" name="submit">Upload</button>
                <button type="button" class="btn btn-primary" id="play_button">Play/Pause</button>
                <label id="month"></label>
                <input id="slider" type="range" min="1" max="11" step="1" value="1"></input>
                <label id="delaytime"></label>
                <input id="delaySlider" type="range" min="1" max="3" step="1" value="1"></input>
                <br>
                <div style="float:right" class="btn-group" role="group" aria-label="cfhMap_type">
                    <input type="radio" class="btn-check" name="btnradioMap" id="rd_densitymap" autocomplete="off" checked>
                    <label class="btn btn-outline-primary" for="rd_densitymap">Density Map</label>
                    
                    <input type="radio" class="btn-check" name="btnradioMap" id="rd_labelmap" autocomplete="off">
                    <label class="btn btn-outline-primary" for="rd_labelmap">Label Map</label>
                </div>
                <br>
                <br>
                <div class="input-group mb-3">
                    <input type="text" class="form-control" id='thresholdSet' placeholder="threshold ('0.01')" aria-label="Recipient's username" aria-describedby="basic-addon2">
                    <div class="input-group-append">
                    <button class="btn btn-outline-secondary" type="button" onclick="updateThreshold()">Update</button>
                    </div>
                </div>
                <div class="input-group mb-3">
                    <input type="text" class="form-control" id='featureStrSet' placeholder="featureStr ('01')" aria-label="Recipient's username" aria-describedby="basic-addon2">
                    <div class="input-group-append">
                    <button class="btn btn-outline-secondary" type="button" onclick="updateFeatureStr()">Update</button>
                    </div>
                </div>
            </div>
            <div class="tab-pane fade" id="pills-profile" role="tabpanel" aria-labelledby="pills-profile-tab">
                <div style="float:right" class="btn-group" role="group" aria-label="data_source_type">
                    <input type="radio" class="btn-check" name="btnradio2" id="rd_light" autocomplete="off" checked>
                    <label class="btn btn-outline-primary" for="rd_light">L</label>
                    
                    <input type="radio" class="btn-check" name="btnradio2" id="rd_satellite" autocomplete="off">
                    <label class="btn btn-outline-primary" for="rd_satellite">S</label>
        
                    <input type="radio" class="btn-check" name="btnradio2" id="rd_dark" autocomplete="off">
                    <label class="btn btn-outline-primary" for="rd_dark">D</label>
                    
                    <input type="radio" class="btn-check" name="btnradio2" id="rd_streets" autocomplete="off">
                    <label class="btn btn-outline-primary" for="rd_streets">E</label>
                    
                    <input type="radio" class="btn-check" name="btnradio2" id="rd_outdoors" autocomplete="off">
                    <label class="btn btn-outline-primary" for="rd_outdoors">O</label>
        
                    <input type="radio" class="btn-check" name="btnradio2" id="rd_terrain" autocomplete="off">
                    <label class="btn btn-outline-primary" for="rd_terrain">T</label>
                </div>
                <br>
                <!-- <div id="key" style="opacity: 0.8;">
                    <div class="blank min"></div><div class="blank max"></div>
                    <div id="min" style="color: white; font-weight: 600;">&lt;16µg/m³</div><div id="max" style="color: white; font-weight: 600;">&gt;97µg/m³</div>
                    <div style="width: 1px; height: 18px; margin: 0 0 0 120px; background: blue"></div>
                </div> -->
                <br>
                <input class="largerCheckbox" type="checkbox" id="graphxy" unchecked><label for="graphxy">Graph XY</label><br>
                <input class="largerCheckbox" type="checkbox" id="rotate" unchecked><label for="rotate">Auto rotate</label><br>
                <input class="largerCheckbox" type="checkbox" id="networkdrawEnabled" unchecked><label for="networkdrawEnabled">Draw optimized test</label><br>
                <input class="largerCheckbox" type="checkbox" id="terrainEnabled" unchecked><label for="terrainEnabled">Terrain layer</label><br>
                <input class="largerCheckbox" type="checkbox" id="buildingEnabled" unchecked><label for="buildingEnabled">Building layer</label><br>
                <input class="largerCheckbox" type="checkbox" id="POIEnabled" checked><label for="POIEnabled">POIs layer</label><br>
                <input class="largerCheckbox" type="checkbox" id="nodesEnabled" checked><label for="nodesEnabled">Intersection layer</label><br>
                <input class="largerCheckbox" type="checkbox" id="rawroadEnabled" checked><label for="rawroadEnabled">Road layer</label><br>
                <input class="largerCheckbox" type="checkbox" id="taperedEnabled" checked><label for="taperedEnabled">Network color mapping</label><br>
                <input class="largerCheckbox" type="checkbox" id="colormapping" checked><label for="colormapping">Density color mapping</label><br>
                <input class="largerCheckbox" type="checkbox" id="heightmapping" checked><label for="heightmapping">Height mapping</label><br>
                <input class="largerCheckbox" type="checkbox" id="heightcfh" unchecked><label for="heightcfh">Height CFH</label><br>
                <label id="alpha"></label>
                <input id="alphaslider" type="range" min="0" max="100" step="1" value="80"></input>
                <div><label>Camera&nbsp</label><button type="button" class="btn btn-outline-secondary" onclick="copyCameraPosition()">Copy</button>
                <button type="button" class="btn btn-outline-secondary" onclick="pasteCameraPosition()">Paste</button></div>
            </div>
          </div>
    </div>
    
        <div id="info">
            <div><strong>VectexId:</strong> <span id='VectexId'></span></div>
            <div><strong>Lng:</strong> <span id='Longitude'></span></div>
            <div><strong>Lat:</strong> <span id='Latitude'></span></div>
            <div><strong>Color alpha:</strong> <span id='Color_alpha'></span></div>
            <br>
            <div><strong>cfh height:</strong> <span id='height'></span></div>
            <div><strong>cfh binaryStr:</strong> <span id='binaryStr'></span></div>
            <div><strong>cfh featureStr:</strong> <span id='featureStr'></span></div>
            <div><strong>cfh change threshold:</strong> <span id='threshold'></span></div>
            <br>
            <div><strong>tdm color:</strong> <span id='tdm_color'></span><div class="box" id="tdm_color_sample" style="background-color: #723122"></div></div>
            <div><strong>cfh value max:</strong> <span id='cfh_value_max'></span></div>
            <div><strong>cfh value min:</strong> <span id='cfh_value_min'></span></div>
            <div><strong>tdm lambda:</strong> <span id='tdm_lambda'></span></div>
            <div><strong>access time (s):</strong> <span id='access_time'></span></div>
            <div><strong>ift cost (E dis^2):</strong> <span id='ift_cost'></span></div>
            <div><strong>tdm cost (m):</strong> <span id='tdm_cost'></span></div>
            <div class="scrollbar scrollbar-primary">
                <div class="force-overflow"><div><strong>cfh matrix:</strong> <span id='cfh_matrix'></span></div>
                </div>
            </div>
    </div>  
</div>
<div id="panel_control" class="overlay closed"></div>
<script>

var triggerTabList = [].slice.call(document.querySelectorAll('#pills-tab a'))
triggerTabList.forEach(function (triggerEl) {
  var tabTrigger = new bootstrap.Tab(triggerEl)

  triggerEl.addEventListener('click', function (event) {
    event.preventDefault()
    tabTrigger.show()
  })
})

    async function loadGeoJsonFile()
{
    const response = await fetch(
        'polygon.geojson'
        );
    rawdata = await response.json();
    console.log(rawdata)
}

let hoveredStateId = null;
let hoveredNodeId = null;
let hoveredEdgeId = null;
let hoveredProps = null;
var last = Date.now();
let enableRotate = false;
let startangle = 0;
let cameraPos = {center: [6.1645443, 62.4720013], zoom: 16, pitch: 0, bearing: 0};
let lon_min;
let lat_min;
let lon_step;
let lat_step;
let nrows;
let ncols;
let startnode_index;
let clrPOIs;
let indexPOIs;
// markers saved here
let currentMarkers=[];
let isLabelMatrix = false;

a = false;
b = false;

featureStr = "01";
Threshold = 0.0002;
timesteps = 10;
var g_play = false;
//var g_playspeed = 1;
var g_playwait = 1;

const markerHeight = 50;
const markerRadius = 10;
const linearOffset = 25;
const popupOffsets = {
'top': [0, 0],
'top-left': [0, 0],
'top-right': [0, 0],
'bottom': [0, -markerHeight],
'bottom-left': [linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
'bottom-right': [-linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
'left': [markerRadius, (markerHeight - markerRadius) * -1],
'right': [-markerRadius, (markerHeight - markerRadius) * -1]
};

loadGeoJsonFile();

mapboxgl.accessToken = 'pk.eyJ1IjoiZmVsYW5kbyIsImEiOiJjbDI0dHJ4cHIyMzhmM2lscHBiZ2VybWl0In0.O46bIQ6f08o0E55XLhESZg';
styleStr = 'mapbox://styles/mapbox/light-v10';
map = new mapboxgl.Map({
    style: styleStr, 
//style: 'mapbox://styles/mapbox/light-v10',
//style: 'mapbox://styles/mapbox/streets-v11',
//style: 'mapbox://styles/mapbox-map-design/ckhqrf2tz0dt119ny6azh975y',
center: cameraPos.center,//[6.1645443, 62.4720013],
zoom: cameraPos.zoom,//16,
pitch: cameraPos.pitch,//0,
bearing: cameraPos.bearing,//0,
container: 'map',
antialias: true
});
loadBasicLayger();

layerId = "light-v10";
labelLayerId = 0;

radarData =  {
'type': 'image',
'url': 'https://docs.mapbox.com/mapbox-gl-js/assets/radar.gif',
'coordinates': [
[6.1589338, 62.4723013],
[6.1644474, 62.47264497],
[6.165792, 62.471144],
[6.1596182, 62.4714755]
]
}

pointlist = {
'type': 'FeatureCollection',
'features': [
{
// H1， 278087398，62.4723013,6.1589338
'type': 'Feature',
'geometry': {
'type': 'Point',
'coordinates': [
6.1589338, 62.4723013
]
},
'properties': {
'title': 'H1',
'color': "blue"
}
}
]
}

let gjFeatureC_Array = [];
let gjFeatureC = {};
var TgjFeatureC = {
    "name":"NewFeatureType",
    "type":"FeatureCollection",
    "features":[]
};
var TgjFeature = {
    "type":"Feature",
    "geometry":{
        "type":"MultiPolygon",
        "coordinates":[]
    },
    "properties":null
};
let gjFeatureC_Array_Nodes = [];
let gjFeatureC_Nodes = {};
let gjFeatureC_Array_POIs = [];
let gjFeatureC_POIs = {};


function ComputeCFH(Matrix, featureStr, Threshold)
{
if(Matrix.length >= featureStr.length)
{ 
    let binaryStr = "";
    for(i = 0; i < 4; i++)//Matrix.length - 1
    {
        if(Math.abs(Matrix[i+1] - Matrix[i]) >= Threshold)
        {
            console.log(Math.abs(Matrix[i+1] - Matrix[i]));
            binaryStr +="1";
        }
        else
            binaryStr +="0";
    }
    console.log(binaryStr)
    return [binaryStr, binaryStr.split(featureStr).length - 1];
}
else
    return ["", 0]
}

function loadBasicLayger()
{
map.on('style.load', (e) => {

map.addSource('mapbox-dem', {
'type': 'raster-dem',
'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
'tileSize': 512,
'maxzoom': 14
});

// // add a sky layer that will show when the map is highly pitched
map.addLayer({
'id': 'sky',
'type': 'sky',
'paint': {
'sky-type': 'atmosphere',
'sky-atmosphere-sun': [0.0, 0.0],
'sky-atmosphere-sun-intensity': 15
}
});

if(layerId != "satellite-v9")
{
        const layers = map.getStyle().layers;
    labelLayerId = layers.find(
    (layer) => layer.type === 'symbol' && layer.layout['text-field']
    ).id;
    //console.log(layers)
    //console.log(labelLayerId)
    // The 'building' layer in the Mapbox Streets
    // vector tileset contains building height data
    // from OpenStreetMap.
    map.addLayer(
    {
    'id': 'add-3d-buildings',
    'source': 'composite',
    'source-layer': 'building',
    'filter': ['==', 'extrude', 'true'],
    'type': 'fill-extrusion',
    'minzoom': 15,
    'layout': {
                // Make the layer visible by default.
                'visibility': 'none'
            },
    'paint': {
    'fill-extrusion-color': 'lightyellow',

    // Use an 'interpolate' expression to
    // add a smooth transition effect to
    // the buildings as the user zooms in.
    'fill-extrusion-height': [
    'interpolate',
    ['linear'],
    ['zoom'],
    15,
    0,
    15.05,
    ['get', 'height']
    ],
    'fill-extrusion-base': [
    'interpolate',
    ['linear'],
    ['zoom'],
    15,
    0,
    15.05,
    ['get', 'min_height']
    ],
    'fill-extrusion-opacity': 0.6
    }
    },
    labelLayerId
    );
}

map.addSource('states', {
'type': 'geojson',
'data': 'polygon.geojson'//'https://docs.mapbox.com/mapbox-gl-js/assets/us_states.geojson'
});

// Add an image to use as a custom marker
map.loadImage(
'https://docs.mapbox.com/mapbox-gl-js/assets/custom_marker.png',
(error, image) => {
if (error) throw error;
map.addImage('custom-marker', image);
// Add a GeoJSON source with 4 points
map.addSource('points', {
'type': 'geojson',
'data': pointlist});


// map.addSource('radar', radarData);
// map.addLayer({
// id: 'radar-layer',
// 'type': 'raster',
// 'source': 'radar',
// 'paint': {
// 'raster-fade-duration': 0
// }
// });

// map.addSource('polygon1', {
// type: 'geojson',
// // Use a URL for the value for the `data` property.
// data: rawdata,//'polygon.geojson',
// });
// // Add a new layer to visualize the polygon.
// map.addLayer({
// 'id': 'poly1',
// 'type': 'fill',
// 'source': 'polygon1', // reference the data source
// 'layout': {},
// 'paint': {
// 'fill-color': '#00ff00', // blue color fill
// 'fill-opacity': 1.0
// }
// });

// Add a data source containing GeoJSON data.
map.addSource('maine', {
'type': 'geojson',
'data': {
'type': 'Feature',
'id': 1,
'geometry': {
'type': 'Polygon',
// These coordinates outline Maine.
'coordinates': [
[
[6.1589338, 62.4723013],
[6.1644474, 62.47264497],
[6.165792, 62.471144],
[6.1596182, 62.4714755],
[6.1589338, 62.4723013],
]
]
}
}
});
// Add a new layer to visualize the polygon.
map.addLayer({
'id': 'maine',
'type': 'fill',
'source': 'maine', // reference the data source
'layout': {},
'filter': ['==', '$type', 'Polygon'],
'paint': {
'fill-color': '#0080ff', // blue color fill
'fill-opacity': [
        'case',
        ['boolean', ['feature-state', 'hover'], false],
        1,
        0
        ]
}
});

// Add a data source containing GeoJSON data.
map.addSource('road1', {
'type': 'geojson',
lineMetrics: true,
'data': {
'type': 'Feature',
'geometry': {
'type': 'LineString',
// These coordinates outline Maine.
'coordinates': [
[
[6.1589338, 62.4723013],
[6.16444, 62.47264497],
[6.165792, 62.471144],
[6.1596182, 62.4714755],
]
]
}
}
});
// 'line-gradient' can only be used with GeoJSON sources
// and the source must have the 'lineMetrics' option set to true
map.addSource('line', {
type: 'geojson',
lineMetrics: true,
data: null
});

map.addSource('nodes', {
type: 'geojson',
lineMetrics: true,
data: null
});



// // the layer must be of type 'line'
// map.addLayer({
// type: 'line',
// source: 'line',
// id: 'line',
// paint: {
// 'line-color': 'red',
// 'line-width': 10,
// 'line-width': 20,
// "line-dasharray": [2, 4]
// }
// });
}
);

const geojson1 = {
'type': 'FeatureCollection',
'features': [
{
'type': 'Feature',
'properties': {},
'geometry': {
'coordinates': [
[[[6.1589338,62.4723013],[6.16444,62.47264497],[6.164436885306187,62.472694872892525],[6.158932554122474,62.472321261157006],[6.1589338,62.4723013]]],
[[[6.16444,62.47264497],[6.165792,62.471144],[6.165806860333545,62.47115738545804],[6.164477150833863,62.47267843364509],[6.16444,62.47264497]]],
[[[6.165792,62.471144],[6.1596182,62.4714755],[6.159615519129591,62.47142557192239],[6.165790927651837,62.471124028768955],[6.165792,62.471144]]],
[[[6.1596182,62.4714755],[6.1589338,62.4723013],[6.1589184010870275,62.47228853781056],[6.1595797027175685,62.4714435945264],[6.1596182,62.4714755]]
]]
// [6.1589338, 62.4723013],
// [6.16444, 62.47264497],
// [6.165792, 62.471144],
// [6.1596182, 62.4714755],
,
'type': 'MultiPolygon'
}
},
{
'type': 'Feature',
'properties': {},
'geometry': {
'coordinates': [
[[[6.1589338,62.4723013],[6.16444,62.47264497],[6.164436885306187,62.472694872892525],[6.158932554122474,62.472321261157006],[6.1589338,62.4723013]]],
[[[6.16444,62.47264497],[6.165792,62.471144],[6.165806860333545,62.47115738545804],[6.164477150833863,62.47267843364509],[6.16444,62.47264497]]],
[[[6.165792,62.471144],[6.1596182,62.4714755],[6.159615519129591,62.47142557192239],[6.165790927651837,62.471124028768955],[6.165792,62.471144]]],
[[[6.1596182,62.4714755],[6.1589338,62.4723013],[6.1589184010870275,62.47228853781056],[6.1595797027175685,62.4714435945264],[6.1596182,62.4714755]]
]]
// [6.1589338, 62.4723013],
// [6.16444, 62.47264497],
// [6.165792, 62.471144],
// [6.1596182, 62.4714755],
,
'type': 'MultiPolygon'
}
}
]
};
//stores = map.queryRenderedFeatures({ layers: ['road1'] })
//console.log(stores)
// if(map.isSourceLoaded("polygon1")){
//         const stores = map.querySourceFeatures("polygon1")
//         console.log(stores)
//     }
});
map.on('sourcedata', (e) => {
    //console.log(e)
    if(!a && e.sourceId === "points" && map.isSourceLoaded("points")){
        //console.log("abc")
        // pointlist.features[0].properties.title = "H1";//H101
        // console.log(pointlist)
        // map.getSource('points').setData(pointlist);
        // Add a symbol layer
        map.addSource('polygon1', {
        type: 'geojson',
        // Use a URL for the value for the `data` property.
        data: rawdata,//'polygon.geojson',
        });

        map.addLayer({
            'id': 'room-extrusion',
            'type': 'fill-extrusion',
            'source': 'polygon1',
            'layout': {
                // Make the layer visible by default.
                'visibility': 'visible'
            },
            'filter': ['==', '$type', 'Polygon'],
            'paint': {
            // Get the `fill-extrusion-color` from the source `color` property.
            //'fill-extrusion-color': ['get', 'color'],
            'fill-extrusion-color':[
                'case',
                ['boolean', ['feature-state', 'hover'], false],
                "black",
                ['get', 'clrA']//"grey"
                ],//"grey",
            
            // Get `fill-extrusion-height` from the source `height` property.
            'fill-extrusion-height': ['get', 'height'],
            
            // Get `fill-extrusion-base` from the source `base_height` property.
            //'fill-extrusion-base': ['get', 'base_height'],
            
            // Make extrusions slightly opaque to see through indoor walls.
            'fill-extrusion-opacity': document.getElementById('alphaslider').value/100//0.8
            }
            });
        
        
            addLayers_Hover();

            // color map for the TTDM
            // Add a new layer to visualize the polygon.
            // map.addLayer({
            //     'id': 'poly1',
            //     'type': 'fill',
            //     'source': 'polygon1', // reference the data source
            //     'layout': {
            //         // Make the layer visible by default.
            //         'visibility': 'visible'
            //     },
            //     'filter': ['==', '$type', 'Polygon'],
            //     'paint': {
            //     'fill-color': ['get', 'clrA'],//'color'],//'#00ff00', // blue color fill
            //     'fill-opacity': 0.5//['get', 'alpha']
            //     }
            // });

            // Add a new layer to visualize the polygon.
            map.addLayer({
                'id': 'road',
                'type': 'fill',
                'source': 'line', // reference the data source
                'layout': {
                    // Make the layer visible by default.
                    'visibility': 'visible',//'visible'
                },
                'paint': {
                'fill-color': [
                    'case',
                    ['boolean', ['feature-state', 'hover'], false],
                    "black",
                    ['get', 'color']//"grey"
                    ],//['get', 'color']//'#000000', // blue color fill
                'fill-opacity': 1
                }
            });

            // raw road
            // Add a new layer to visualize the polygon.
            map.addLayer({
                'id': 'rawroad',
                'type': 'line',
                'source': 'polygon1', // reference the data source
                'layout': {
                    // Make the layer visible by default.
                    'visibility': 'visible'//'none'
                },
                'filter': ['==', '$type', 'LineString'],
                paint: {
                'line-color': 'black',
                'line-width': 2
                }
            });

            // intersection, nodes
            // Add a layer showing the places.
            map.addLayer({
                'id': 'nodeslayer',
                'type': 'circle',
                'source': 'nodes',
                'layout': {
                    // Make the layer visible by default.
                    'visibility': 'visible'//'none'
                },
                'paint': {
                    'circle-color': ['get', 'color'],
                    'circle-radius': [
                    'case',
                    ['boolean', ['feature-state', 'hover'], false],
                    20,
                    5//"grey"
                    ],
                    'circle-stroke-width': 1,
                    'circle-stroke-color': '#ffffff'
            }
            });

            // Add a symbol layer
            map.addLayer({
                'id': 'points',
                'type': 'symbol',
                'source': 'points',
                'layout': {
                    'visibility': 'visible',//'none'
                    //'icon-image': 'custom-marker',
                    // get the title name from the source's "title" property
                    'text-field': ['get', 'title'],
                    'text-font': [
                    'Open Sans Semibold',
                    'Arial Unicode MS Bold'
                ],
                'text-size': 25,
                'text-offset': [0, -2.5],
                'text-anchor': 'top',
                },
                'paint': {
                    'text-color': ['get', 'color'],
                    "text-halo-width": 0.5,
                    "text-halo-color": "black",
                    //'text-halo-blur':1,
                },
            });
        a = true;
    }
})

// after load the polygon raw data file, add layers
map.on('sourcedata', (e) => {
    //console.log(e)
    if(!b && e.sourceId === "polygon1" && map.isSourceLoaded("polygon1")){
        updateData();

        cameraPos = {"center":{"lng":6.164544300000017,"lat":62.47200129999996},"zoom":16,"pitch":72.51072648495212,"bearing":43.206391505516535};
        updateCameraPosition();

        //
        var tick = function() {
            tick_update();
            window.requestAnimationFrame(tick, map);
        };
        tick();
        rotateCamera(0);
        b = true;
    }
})

// When a click event occurs on a feature in the states layer,
// open a popup at the location of the click, with description
// HTML from the click event's properties.
map.on('click', 'room-extrusion', (e) => { //poly1
    //console.log(123)
new mapboxgl.Popup()//({className:"popstyle"})
.setLngLat(e.lngLat)
.setHTML(infoList.innerHTML)//e.features[0].properties.cfh + "," + e.features[0].properties.name + "," + e.lngLat)
.addTo(map);

//console.log(infoList.outerHTML)
});

// map.on('click', 'poly1', (e) => { 
//     //console.log(123)
// new mapboxgl.Popup()//({className:"popstyle"})
// .setLngLat(e.lngLat)
// .setHTML(infoList.innerHTML)//e.features[0].properties.cfh + "," + e.features[0].properties.name + "," + e.lngLat)
// .addTo(map);

// //console.log(infoList.outerHTML)
// });

    activeHoverNodes();
    activeHoverEdges();
    activeHoverTexture();
}

function updateData()
{
    //console.log("abc")
    //console.log(rawdata.features.length)
    //console.log(rawdata.features[0].properties.name)

    i = rawdata.features.length - 2;

    lambda_min = rawdata.features[i].properties.tdm_lambda_min;
    lambda_max = rawdata.features[i].properties.tdm_lambda_max;

    Threshold = (lambda_max - lambda_min) / 20;
    let timesteps;

    if(isLabelMatrix)
    {
        timesteps = rawdata.features[0].properties.cfh_labelmatrix.length;
        dcfh_value_min.textContent = 0;
        dcfh_value_max.textContent =  rawdata.features[i].properties.indexPOIs.length - 1;
        Threshold = 1;
        dthreshold.textContent = Threshold;
    }
    else
    {
        timesteps = rawdata.features[0].properties.cfh_matrix.length;
        dcfh_value_min.textContent = parseFloat(lambda_min.toFixed(6));
        dcfh_value_max.textContent = parseFloat(lambda_max.toFixed(6));
        dthreshold.textContent = parseFloat(Threshold.toFixed(4));
    }

    dfeatureStr.textContent = featureStr;
    //console.log(rawdata.features.length)
    //console.log(timesteps)


    document.getElementById('slider').setAttribute("max",timesteps);//40);
    
    computeTTDM();

    document.getElementById('delaytime').textContent = "delay: " + g_playwait + " seconds";
    document.getElementById('month').textContent = "time:" + document.getElementById('slider').value + "/" + timesteps;
    document.getElementById('alpha').textContent = "Alpha:" + document.getElementById('alphaslider').value + "%";

    createNodes();
    removePOInodes();
    if(document.getElementById('POIEnabled').checked)
    {
        createPOInodes();
    }
    networkmappingChange()
    colormappingChanged();
    heightmappingChanged();
    graphxyChanged();
    terrainChanged();
    buildingChanged();
}

function computeTTDM()
{
    heightcfh = document.getElementById("heightcfh").checked;
    colormap = document.getElementById('colormapping').checked;
    heightmap = document.getElementById("heightmapping").checked;
    // load global properties
    i = rawdata.features.length-2;
    props = rawdata.features[i].properties;
    ncols = props.ncols;
    nrows = props.nrows;
    lon_min = props.lon_min;
    lat_min = props.lat_min;
    lon_step = props.lon_step;
    lat_step = props.lat_step;
    clrPOIs = props.clrPOIs;
    indexPOIs = props.indexPOIs;
    //console.log(lon_min);
    //console.log(lon_min + lon_step);

    for(i=0; i<rawdata.features.length-2;i++)//rawdata.features.length-1
    {
        props = rawdata.features[i].properties;
        props.color = props.tdm_color;
        // color mapping with lambda value
        props.alpha = 1 - (props.tdm_lambda - lambda_min) / (lambda_max - lambda_min);
        props.clrA = computeClrA(props.color, props.alpha);
        if(isLabelMatrix)
            matrix = props.cfh_labelmatrix;
        else
            matrix = props.cfh_matrix;

        if(matrix.length >= featureStr.length)
        { 
            let binaryStr = "";
            for(j = 0; j < matrix.length - 1; j++)//Matrix.length - 1
            {
                //console.log(matrix[j+1]);
                //console.log(Math.abs(matrix[j+1] - matrix[j]));
                if(Math.abs(matrix[j+1] - matrix[j]) >= Threshold)
                {
                    binaryStr +="1";
                }
                else
                    binaryStr +="0";
            }
            //console.log(binaryStr)
            //console.log( binaryStr.split(featureStr).length - 1)
            props.cfh_bstr = binaryStr;
            if(!heightcfh)
                props.height = 10 * (binaryStr.split(featureStr).length - 1) / (1 + props.tdm_cost);
            else
                props.height = (binaryStr.split(featureStr).length - 1);
        }
        else
        {
            props.cfh_bstr = "";
            props.height = 0;
        }
        if(colormap && !heightmap)
            props.height = 0;
        else if(!colormap && heightmap)
        {
            props.clrA = computeClrA('#000000', props.alpha);
        }
    }

    map.getSource('polygon1').setData(rawdata);
    //console.log(rawdata)
}

function createNodes()
{
    i = rawdata.features.length - 2;
    nodes_geo = rawdata.features[i].properties.nodes_geo;
    nodes_name = rawdata.features[i].properties.nodes_name;
    
    {
        n_nodes = nodes_geo.length;
        //console.log(n_edges)
        timesteps = rawdata.features[0].properties.cfh_matrix.length;
        gjFeatureC_Array_Nodes = [];
        for(k=1; k<timesteps+1;k++)
        {
            gjFeatureC_Nodes = JSON.parse(JSON.stringify(TgjFeatureC));
            for(j = 0; j < n_nodes; j++)//n_nodes
            {
                gjFeature = JSON.parse(JSON.stringify(TgjFeature));
                gjFeature.geometry.type = "Point";
                gjFeature.geometry.coordinates = nodes_geo[j];
                gjFeature.properties = {'name': nodes_name[j],'index': j,
                    'color': 'black'};//rawdata.features[startnode_index].properties.color}
                gjFeatureC_Nodes.features.push(gjFeature);
            }
            //console.log(gjFeatureC)
            gjFeatureC_Array_Nodes.push(gjFeatureC_Nodes);
        }
    }
    console.log("nodes loaded")
    //rawdata.features.pop();
    //console.log(JSON.stringify(gjFeatureC));
    //console.log(JSON.stringify(gjFeatureC_Array_Nodes[0]))
    map.getSource('nodes').setData(gjFeatureC_Array_Nodes[0]);
}

function removePOInodes()
{
    // remove markers 
    if (currentMarkers!==null) {
        for (var i = currentMarkers.length - 1; i >= 0; i--) {
        currentMarkers[i].remove();
        }
    }
}

function createPOInodes()
{
    i = rawdata.features.length - 2;
    gjFeatureC_Array_POIs = [];
    gjFeatureC_POIs = JSON.parse(JSON.stringify(TgjFeatureC));
    for(i=0; i<indexPOIs.length;i++)
    {
        //console.log(indexPOIs[i])
        gjFeature = JSON.parse(JSON.stringify(TgjFeature));
        gjFeature.geometry.type = "Point";
        gjFeature.geometry.coordinates = nodes_geo[indexPOIs[i]];
        gjFeature.properties = {'title': 'H'+ (i+1).toString(),'color': clrPOIs[i]};
        gjFeatureC_POIs.features.push(gjFeature);
        //console.log(JSON.stringify(gjFeatureC_POIs));

        // tmp marker
        var oneMarker= new mapboxgl.Marker({color:clrPOIs[i]})
            .setLngLat(gjFeature.geometry.coordinates)
            .addTo(map);

        // save tmp marker into currentMarkers
        currentMarkers.push(oneMarker);
    }
    gjFeatureC_Array_POIs.push(gjFeatureC_POIs);

    console.log("POI nodes updated")
    //rawdata.features.pop();
    //console.log(JSON.stringify(gjFeatureC_POIs));
    //console.log("abc" + JSON.stringify(gjFeatureC_Array_POIs))
    map.getSource('points').setData(gjFeatureC_Array_POIs[0]);
}

function activeHoverNodes()
{
    // Create a popup, but don't add it to the map yet.
    const popup = new mapboxgl.Popup({
        closeButton: false,
        closeOnClick: false
        });
        map.on('mouseenter', 'nodeslayer', (e) => {
        // Change the cursor style as a UI indicator.
        map.getCanvas().style.cursor = 'pointer';
        
        //console.log(e.features[0].properties.name)
        // Copy coordinates array.
        const coordinates = e.features[0].geometry.coordinates.slice();
        const description ="<b>Node</b>"+ "\n<b>Index</b>:" + e.features[0].properties.index
            + "\n<br><b>Name:</b>" + e.features[0].properties.name 
            + "\n<b>Lng</b>:" + e.features[0].geometry.coordinates[0] 
            + "\n<b>Lat</b>:" + e.features[0].geometry.coordinates[1];
        
        // Ensure that if the map is zoomed out such that multiple
        // copies of the feature are visible, the popup appears
        // over the copy being pointed to.
        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
        coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }
        
        // Populate the popup and set its coordinates
        // based on the feature found.
        popup.setLngLat(coordinates).setHTML(description).addTo(map);
        });
        
        map.on('mouseleave', 'nodeslayer', () => {
        map.getCanvas().style.cursor = '';
        popup.remove();
        });         
}

function activeHoverEdges()
{
    // Create a popup, but don't add it to the map yet.
    const popup = new mapboxgl.Popup({
        closeButton: false,
        closeOnClick: false
        });
        map.on('mouseenter', 'road', (e) => {
        // Change the cursor style as a UI indicator.
        map.getCanvas().style.cursor = 'pointer';
        
        if (hoveredEdgeId !== null) {
        map.setFeatureState(
        { source: 'line', id: hoveredEdgeId },
        { hover: false }
        );
        }

        hoveredEdgeId = e.features[0].id ;
        map.setFeatureState(
        { source: 'line', id: hoveredEdgeId },
        { hover: true }
        );

        //console.log(e.features[0].properties)
        const description ="<b>Edge</b>\n<b>Index:</b>" + e.features[0].properties.index 
            + "\n<br><b>Nodes</b>:(" + e.features[0].properties.startnode_index
            + "," + e.features[0].properties.stopnode_index
            + ")<br><b>Color:</b><span></span>" + e.features[0].properties.color + "<div class='box' id='tdm_color_sample' style='background-color: " + e.features[0].properties.color
            + "'></div>";
        //console.log(description)
        
        
        // Populate the popup and set its coordinates
        // based on the feature found.
        popup.setLngLat(e.lngLat).setHTML(description).addTo(map);
        });
        
        map.on('mouseleave', 'road', () => {
        map.getCanvas().style.cursor = '';
        popup.remove();
        if (hoveredEdgeId !== null) {
        //console.log(hoveredStateId + ":false");
        map.setFeatureState(
        { source: 'line', id: hoveredEdgeId },
        { hover: false }
        );
        }
        });         
}

function activeHoverTexture()
{
    // Change the cursor to a pointer when
    // the mouse is over the states layer.
    map.on('mouseenter', 'room-extrusion', () => {
    map.getCanvas().style.cursor = 'pointer';
    });

    // Change the cursor back to a pointer
    // when it leaves the states layer.
    map.on('mouseleave', 'room-extrusion', () => {
    map.getCanvas().style.cursor = '';
    });

    // When the user moves their mouse over the state-fill layer, we'll update the
    // feature state for the feature under the mouse.
    map.on('mousemove', 'state-fills', (e) => {
    
    //console.log(e.features[0].geometry.type)
    if ((e.features.length > 0) && (e.features[0].geometry.type == 'Polygon')) {
    if (hoveredStateId !== null) {
    map.setFeatureState(
    { source: 'polygon1', id: hoveredStateId },
    { hover: false }
    );
    }
    //console.log(JSON.stringify(e.features[0]));

    hoveredStateId = e.features[0].id;
    hoveredProps = e.features[0].properties;
    map.setFeatureState(
    { source: 'polygon1', id: hoveredStateId },
    { hover: true }
    );
    dVectexId.textContent = hoveredStateId;
    dLatitude.textContent = e.lngLat.lat;
    dLongitude.textContent = e.lngLat.lng;

    props = e.features[0].properties;
    //console.log(JSON.stringify(props))
    //if(props != null)
    {
        dColor_alpha.textContent = parseFloat(props.alpha.toFixed(6));
        dtdm_color.textContent = props.color;
        dtdm_color_sample.style.backgroundColor = props.color;
        dtdm_lambda.textContent = parseFloat(props.tdm_lambda.toFixed(6));
        daccess_time.textContent = parseFloat(props.tdm_accesstime.toFixed(6));
        dift_cost.textContent = parseFloat(props.ift_cost.toFixed(6));
        dtdm_cost.textContent = parseFloat(props.tdm_cost.toFixed(6));
        dheight.textContent = parseFloat(props.height.toFixed(6));
        dbinaryStr.textContent = chunkString(props.cfh_bstr, 10);
        if(isLabelMatrix)
            dcfh_matrix.textContent = props.cfh_labelmatrix.toString().split(',').join(',\n');
        else
            dcfh_matrix.textContent = props.cfh_matrix.toString().split(',').join(',\n');
        
        //console.log(hoveredStateId + ":true");
    }
    }
    });

    // When the mouse leaves the state-fill layer, update the feature state of the
    // previously hovered feature.
    map.on('mouseleave', 'state-fills', (e) => {
    if (hoveredStateId !== null) {
        //console.log(hoveredStateId + ":false");
    map.setFeatureState(
    { source: 'polygon1', id: hoveredStateId },
    { hover: false }
    );
    dVectexId.textContent = "No data";;
    dLatitude.textContent = "";
    dLongitude.textContent = "";
    dColor_alpha.textContent = "";
    dtdm_color.textContent = "";
    dtdm_color_sample.style.backgroundColor = "white";
    dtdm_lambda.textContent = "";
    daccess_time.textContent = "";
    dift_cost.textContent = "";
    dtdm_cost.textContent = "";
    dheight.textContent = "";
    dbinaryStr.textContent = "";
    dcfh_matrix.textContent = "";
    }
    hoveredStateId = null;
    hoveredProps = null;
    });
}

function networkmappingChange()
{
    draw_opt = document.getElementById('networkdrawEnabled').checked;

    edges = rawdata.features[rawdata.features.length - 1];
    console.log("edge_num:" + edges.geometry.coordinates.length);
    if(edges.geometry.type == "MultiLineString")
    {
        n_edges = edges.geometry.coordinates.length;
        //console.log(n_edges)
        timesteps = rawdata.features[0].properties.cfh_matrix.length;
        gjFeatureC_Array = [];
        for(k=1; k<timesteps+1;k++)
        {
            gjFeatureC = JSON.parse(JSON.stringify(TgjFeatureC));
            scale = 0.00001;
            for(j = 0; j < n_edges; j++)//n_edges
            {
                edge = edges.geometry.coordinates[j];
                n_points = edge.length;
                //console.log(JSON.stringify(edge));
                //console.log(JSON.parse(JSON.stringify(TgjFeature)));
                let isVaid = true;
                for(i = 0; i < n_points;i++)
                {
                    x_index = Math.floor((edge[i][0] - lon_min)/lon_step);
                    y_index = Math.floor((edge[i][1] - lat_min)/lat_step);
                    if((x_index < 0) || (x_index >= ncols))
                    {
                        isVaid = false;
                        break;
                    }
                    if((y_index < 0) || (y_index >= nrows))
                    {
                        isVaid = false;
                        break;
                    }
                }

                if(isVaid)
                {
                    gjFeature = JSON.parse(JSON.stringify(TgjFeature));
                    let ConnectedCoorStr = [];
                    for(i = 0; i < n_points -1; i++)//n_points
                    {
                        if(!((edge[i][0] == edge[i+1][0]) && (edge[i][1] == edge[i+1][1])))
                        {
                            CoorStr = TaperedLine2(edge[i], edge[i+1], 8, k);//3*(i)/n_points, 3*(i+1)/n_points);//widths[i], widths[i+1]);
                            if(draw_opt)
                            {
                                //console.log(edge.length);
                                if(ConnectedCoorStr.length == 0)
                                {
                                    ConnectedCoorStr = JSON.parse(JSON.stringify(CoorStr))[0];
                                    //console.log(JSON.stringify(CoorStr));
                                }
                                else
                                {
                                    l = ConnectedCoorStr.length;
                                    p1 = ConnectedCoorStr.slice(0, (l-1)/2);
                                    p2 = CoorStr[0].slice(0, CoorStr[0].length - 1);
                                    p3 = ConnectedCoorStr.slice((l-1)/2, l);
                                    ConnectedCoorStr = p1.concat(p2).concat(p3);
                                    //console.log(p1.length + "+" + p2.length + "+" + p3.length + "=" + ConnectedCoorStr.length);
                                }
                            }
                            else
                                gjFeature.geometry.coordinates.push(CoorStr);
                        }
                    }
                    if(draw_opt)
                        gjFeature.geometry.coordinates.push([ConnectedCoorStr]);
                    x_index = Math.floor((edge[0][0] - lon_min)/lon_step);
                    y_index = Math.floor((edge[0][1] - lat_min)/lat_step);
                    startnode_index = x_index + y_index * ncols;
                    x_index = Math.floor((edge[n_points -1][0] - lon_min)/lon_step);
                    y_index = Math.floor((edge[n_points -1][1] - lat_min)/lat_step);
                    stopnode_index = x_index + y_index * ncols;
                    //console.log(startnode_index)
                    if((startnode_index < rawdata.features.length) && (startnode_index >=0))
                    {
                        gjFeature.id = j;
                        gjFeature.properties = {'index': j, 'startnode_index': startnode_index, 'stopnode_index': stopnode_index,
                            'color': rawdata.features[startnode_index].properties.color}
                        gjFeatureC.features.push(gjFeature);
                    }
                }
            }
            //console.log(gjFeatureC)
            gjFeatureC_Array.push(gjFeatureC);
        }
    }
    console.log("loaded")
    //rawdata.features.pop();
    //console.log(JSON.stringify(gjFeatureC));
    //console.log(gjFeatureC_Array)
    map.getSource('line').setData(gjFeatureC_Array[0]);
}

// 2 points to 5 points of one polygon
function TaperedLine2Old(data1,data2,width1,width2){
    poly = [];
    poly.push(data1);
    poly.push(data2);
    poly.push(ExtendedPointPrev(data2, data1, width2));
    poly.push(ExtendedPointNext(data1, data2, width1));
    poly.push(data1);
    return [poly]
}

// 2 points to 5 points of one polygon
function TaperedLine2(data1,data2,widthscale,tk){
    tk_index = tk - 1;
    //console.log(edge[i][0]);
    //console.log(lon_min);
    x_index = Math.floor((data1[0] - lon_min)/lon_step);
    y_index = Math.floor((data1[1] - lat_min)/lat_step);
    // console.log(data1[1])
    // console.log(lat_min)
    // console.log(lat_step)
    // console.log(y_index)
    // startnode_index = x_index + y_index * ncols;
    //console.log(x_index + y_index * ncols);
    //console.log(props.cfh_matrix[tk_index])
    props = rawdata.features[x_index + y_index * ncols].properties;
    width1 = widthscale * (1 - (props.cfh_matrix[tk_index] - lambda_min) / (lambda_max - lambda_min)); // (props.tdm_lambda
    x_index = Math.floor((data2[0] - lon_min)/lon_step);
    y_index = Math.floor((data2[1] - lat_min)/lat_step);
    //console.log(x_index + y_index * ncols);
    props = rawdata.features[x_index + y_index * ncols].properties;
    width2 = widthscale * (1 - (props.cfh_matrix[tk_index] - lambda_min) / (lambda_max - lambda_min)); // (props.tdm_lambda
    poly = [];
    poly.push(data1);
    poly.push(data2);
    poly.push(ExtendedPointPrev(data2, data1, width2));
    poly.push(ExtendedPointNext(data1, data2, width1));
    poly.push(data1);
    return [poly]
}

// calculate based on the next point position
function ExtendedPointNext(p, np, w)
{
    w = w * scale;
    //console.log(point[0])
    x1 = p[0]
    x2 = np[0]
    y1 = p[1]
    y2 = np[1]
    // (x1,y1)
    //         (x2,y2)
    d = Math.sqrt((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1));
    x_offset = ((y1-y2) / d)*w;
    y_offset = ((x2-x1) / d)*w;
    //         (x2,y2)
    // (x1,y1)
    return [p[0]-x_offset,p[1]-y_offset/4]
}

// calculate based on the previous point position
function ExtendedPointPrev(p, pp, w)
{
    w = w * scale;
    //console.log(point[0])
    x1 = p[0]
    x2 = pp[0]
    y1 = p[1]
    y2 = pp[1]
    // (x1,y1)
    //         (x2,y2)
    d = Math.sqrt((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1));
    x_offset = ((y1-y2) / d)*w;
    y_offset = ((x2-x1) / d)*w;
    //         (x2,y2)
    // (x1,y1)
    return [p[0]+x_offset,p[1]+y_offset/4]
}

function tick_update()
{
var now = Date.now();   // Calculate the elapsed time
var elapsed = now - last;

if(elapsed > g_playwait * 1000)
{
    if(g_play)
    {
        value = parseInt(document.getElementById('slider').value);
        if(value < timesteps)
            newvalue = value + 1
        else
            newvalue = 1
        document.getElementById('slider').value = newvalue;
        console.log(newvalue)
        update_last();
        console.log("play")
        filterBy(newvalue);
    }
    else
    {
        update_last();
        console.log("wait")
    }
}
}

function update_last()
{
var now = Date.now();   // Calculate the elapsed time
last = now;
}

function addLayers_Hover()
{
// add black outline
map.addLayer({
    'id': 'outline',
    'type': 'line',
    'source': 'polygon1',
    'layout': {},
    'paint': {
    'line-width': [
    'case',
    ['boolean', ['feature-state', 'hover'], false],
    4,
    0
    ],
    'line-color': 'black'
    }
});

// add transparent fill to capture the hover area
// The feature-state dependent fill-opacity expression will render the hover effect
// when a feature's hover state is set to true.
map.addLayer({
    'id': 'state-fills',
    'type': 'fill',
    'source': 'polygon1',
    'layout': {},
    'paint': {
    'fill-color': 'black',
    'fill-opacity': [
    'case',
    ['boolean', ['feature-state', 'hover'], false],
    0,
    0
    ]
    }
});
}


function filterBy(month) {
    // Set the label to the month
    //console.log(month);
    document.getElementById('month').textContent = "time:" + month + "/" + timesteps;
    index = month - 1;

    i = rawdata.features.length - 2;
    lambda_min = rawdata.features[i].properties.tdm_lambda_min;
    lambda_max = rawdata.features[i].properties.tdm_lambda_max;

    if(isLabelMatrix)
    {
        dcfh_value_min.textContent = 0;
        dcfh_value_max.textContent =  rawdata.features[i].properties.indexPOIs.length - 1;
    }
    else
    {
        dcfh_value_min.textContent = parseFloat(lambda_min.toFixed(6));
        dcfh_value_max.textContent = parseFloat(lambda_max.toFixed(6));
    }

    for(i=0; i<rawdata.features.length-2;i++)
    {
        //console.log("abc")
        props = rawdata.features[i].properties;
        props.color = clrPOIs[props.cfh_labelmatrix[index]];
        props.tdm_lambda = props.cfh_matrix[index];
        props.alpha = 1 - (props.tdm_lambda - lambda_min) / (lambda_max - lambda_min);
        props.clrA = computeClrA(props.color, props.alpha);
    }

    map.getSource('polygon1').setData(rawdata);
    if(gjFeatureC_Array.length > 0)
    {
        console.log(gjFeatureC_Array.length);
        map.getSource('line').setData(gjFeatureC_Array[index]);
    }


    // update information
    if(hoveredProps != null)
    {
        props = rawdata.features[hoveredStateId].properties;
        updatelabel(dColor_alpha, props.alpha);
        dtdm_color.textContent = props.color;
        dtdm_color_sample.style.backgroundColor = props.color;
        //matrix = rawdata.features[hoveredStateId].properties.cfh_matrix;
        updatelabel(dtdm_lambda, props.tdm_lambda);
        //console.log("index " + index +',' + matrix[index]);
    }
}

function updatelabel(obj, val)
{
valstr = parseFloat(val.toFixed(6));
if(valstr != obj.textContent)
{
    obj.textContent = valstr;
    obj.setAttribute('class', 'bold');
}
else
    obj.setAttribute('class', 'normal');
}

function play_pause(){
//console.log(g_play, '1');
if(g_play)
{g_play = false;}
else
{
update_last();
g_play = true;
}
}

function rotateCamera() {
//console.log(enableRotate)
if(enableRotate)
{
    // clamp the rotation between 0 -360 degrees
    // Divide timestamp by 100 to slow rotation to ~10 degrees / sec
    angle = (map.getBearing() + 0.1) % 360;
    map.rotateTo(angle, { duration: 0 });
    //console.log(map.getCenter());
    //console.log(map.getZoom());
    //console.log(map.getBearing());
}
else
    startangle = map.getBearing()
// Request the next frame of the animation.
requestAnimationFrame(rotateCamera);
}

function changeSelected(){
enableRotate = document.getElementById("rotate").checked;
console.log(enableRotate)
}

function chunkString(str, length) {
return str.match(new RegExp('.{1,' + length + '}', 'g')).join('\n');
}

function computeClrA(c, a)
{
    var clr = hexToRgb(c);
    var bclr = hexToRgb("#FFFFFF");
    if(a > 1)
        a = 1;
    clr.r = Math.floor(clr.r * a + (1 - a) * bclr.r);
    if(clr.r > 255)
        clr.r = 255;
    clr.g = Math.floor(clr.g * a + (1 - a) * bclr.g);
    if(clr.g > 255)
        clr.g = 255;
    clr.b = Math.floor(clr.b * a + (1 - a) * bclr.b);
    if(clr.b > 255)
        clr.b = 255;
    return rgbToHex(clr.r, clr.g, clr.b)
}

function componentToHex(c) {
var hex = c.toString(16);
return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

//const map;
function loadMap()
{
loadBasicLayger();

}

const mapStyleInput = document.getElementById('mapStyle');

const infoList = document.getElementById('info');

const testbutton = document.getElementById('test');
const testbutton1 = document.getElementById('test1');

const dVectexId = document.getElementById('VectexId');
const dLatitude = document.getElementById('Latitude');
const dLongitude = document.getElementById('Longitude');
const dColor_alpha = document.getElementById('Color_alpha');

const dtdm_color = document.getElementById('tdm_color');
const dtdm_color_sample = document.getElementById('tdm_color_sample');
const dcfh_value_max = document.getElementById('cfh_value_max');
const dcfh_value_min = document.getElementById('cfh_value_min');
const dtdm_lambda = document.getElementById('tdm_lambda');
const daccess_time = document.getElementById('access_time');
const dift_cost = document.getElementById('ift_cost');
const dtdm_cost = document.getElementById('tdm_cost');

const dheight = document.getElementById('height');
const dthreshold = document.getElementById('threshold');
const dbinaryStr = document.getElementById('binaryStr');
const dfeatureStr = document.getElementById('featureStr');
const dcfh_matrix = document.getElementById('cfh_matrix');
const dfeatureStrSet = document.getElementById('featureStrSet');

document.getElementById('slider').addEventListener('input', (e) => {
    //console.log("v" + e.target.value)
    let month = e.target.value;//parseInt(e.target.value, 1);
    //console.log("m" + month)
    if(month != null)
        filterBy(month);
});

document.getElementById('alphaslider').addEventListener('input', (e) => {
    document.getElementById('alpha').textContent = "Alpha:"+e.target.value.toString()+"%";
    map.setPaintProperty('room-extrusion', 'fill-extrusion-opacity', e.target.value / 100)
});

document.getElementById('delaySlider').addEventListener('input', (e) => {
    g_playwait = e.target.value;
    document.getElementById('delaytime').textContent = "delay: " + g_playwait + " seconds";
});


function heightcfhChanged(){
    computeTTDM()
    }

function colormappingChanged(){
    layerStr = 'room-extrusion'
    if(!document.getElementById('colormapping').checked && !document.getElementById('heightmapping').checked)
    {    
    map.setLayoutProperty(
        layerStr,'visibility', 'none');
    }
    else
    {
    map.setLayoutProperty(
        layerStr,'visibility', 'visible');
    } 
    heightcfhChanged()
}

function heightmappingChanged(){
    colormappingChanged()
}

function buildingChanged(){
    layerStr = 'add-3d-buildings'
    if(document.getElementById('buildingEnabled').checked)
    {    
    map.setLayoutProperty(
        layerStr,'visibility', 'visible');
    }
    else
    {
    map.setLayoutProperty(
        layerStr,'visibility', 'none');
    } 
}

function terrainChanged()
{
    if(document.getElementById('terrainEnabled').checked)
    {
        // add the DEM source as a terrain layer with exaggerated height
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });
    }
    else
        map.setTerrain();
}

function taperedEnabled()
{
    updateLayerVisibility('road', 'taperedEnabled')
}

function rawroadEnabled()
{
    updateLayerVisibility('rawroad', 'rawroadEnabled')
}

function nodesEnabled()
{
    updateLayerVisibility('nodeslayer', 'nodesEnabled')
}

function POIEnabled()
{
    updateLayerVisibility('points', 'POIEnabled');
    if(document.getElementById('POIEnabled').checked)
    {
        createPOInodes();
    }
    else
    {
        removePOInodes();
    }
}

function updateLayerVisibility(layerStr, componentStr)
{
    if(document.getElementById(componentStr).checked)
    {
        map.setLayoutProperty(
        layerStr,'visibility', 'visible');
    }
    else
    {
    map.setLayoutProperty(
        layerStr,'visibility', 'none');
    }   
}


function refreshDataSourceTypeFun()
{
    if(document.getElementById("rd_light").checked)
    {
        layerId = "light-v10"
    }
    else if(document.getElementById("rd_satellite").checked)
    {
        layerId = "satellite-v9"
    }
    else if(document.getElementById("rd_dark").checked)
    {
        layerId = "dark-v10"
    }
    else if(document.getElementById("rd_streets").checked)
    {
        layerId = "streets-v11"
    }
    else if(document.getElementById("rd_outdoors").checked)
    {
        layerId = "outdoors-v11"
    }
    else if(document.getElementById("rd_terrain").checked)
    {
        layerId = "terrain"
    }
    else
    {
        layerId = "light"
    }
    console.log(layerId);
    if(layerId == "terrain")
    {
        map.setStyle('mapbox://styles/mapbox-map-design/ckhqrf2tz0dt119ny6azh975y');
        //loadBasicLayger();
    }
    else
        map.setStyle('mapbox://styles/mapbox/' + layerId); 
    a = false;
    b = false;
}

function refreshCfhSourceTypeFun()
{
    if(document.getElementById("rd_densitymap").checked)
    {
        isLabelMatrix = false;
    }
    else if(document.getElementById("rd_labelmap").checked)
    {
        isLabelMatrix = true;
    }
    else
    {
        isLabelMatrix = false;
    }
    updateData();
}

function graphxyChanged()
{
    if(document.getElementById('graphxy').checked)
    {
        document.getElementById('graph2d').setAttribute('class','legendvis')
    }
    else
        document.getElementById('graph2d').setAttribute('class','legend')
}

function doupload() {
let file = document.getElementById('file').files[0];

  (async () => {
    const fileContent = await file.text();
    rawdata = JSON.parse(fileContent);
    console.log('uploaded=', file, ',', rawdata);
    updateData();
    // computeTTDM();
    // // update to new data file
    // networkmappingChange();
  })();
};

function updateFeatureStr()
{
    fstr = document.getElementById('featureStrSet').value;
    console.log("fstr=",fstr);
    var numbers = /^[0-1]+$/;
    if((fstr != "") && fstr.match(numbers))
    {
        featureStr = fstr;
        dfeatureStr.textContent = featureStr;
        computeTTDM();
    }
    else
    {
        document.getElementById('featureStrSet').value = featureStr;
    }
}

function updateThreshold()
{
    fstr = document.getElementById('thresholdSet').value;
    console.log("threshold=",fstr);
    var numbers = /^[0-9]*\.?[0-9]*$/;
    if((fstr != "") && fstr.match(numbers))
    {
        Threshold = parseFloat(fstr);
        console.log(Threshold)
        dthreshold.textContent = Threshold;
        computeTTDM();
    }
    else
    {
        document.getElementById('thresholdSet').value = Threshold;
    } 
}

function copyCameraPosition()
{
    cameraPos.center = map.getCenter();
    cameraPos.zoom = map.getZoom();
    cameraPos.bearing = map.getBearing();
    cameraPos.pitch = map.getPitch();
    navigator.clipboard.writeText(JSON.stringify(cameraPos));
}

async function pasteCameraPosition()
{
    let text = await navigator.clipboard.readText();
    console.log(text);
    if(text.length < 200)
    {
        console.log(text)
        tmp_cameraPos = JSON.parse(text);
        if(tmp_cameraPos.center != null)
        {
            cameraPos.center = tmp_cameraPos.center;
            cameraPos.zoom = tmp_cameraPos.zoom;
            cameraPos.bearing = tmp_cameraPos.bearing;
            cameraPos.pitch = tmp_cameraPos.pitch;
            updateCameraPosition();
            // map.setCenter(cameraPos.center);
            // map.setZoom(cameraPos.zoom);
            // map.setBearing(cameraPos.bearing);
            // map.setPitch(cameraPos.pitch);
        }
    }
}

function updateCameraPosition()
{
    // Using easeTo options.
    map.easeTo({
                center: cameraPos.center,
                zoom: cameraPos.zoom,
                bearing: cameraPos.bearing,
                pitch: cameraPos.pitch,
                speed: 0.2,
                curve: 1,
                duration: 5000,
                easing(t) {
                return t;
            }
            });
}

document.getElementById("play_button").onclick = play_pause;
document.getElementById("rotate").onchange = changeSelected;
document.getElementById("heightcfh").onchange = heightcfhChanged;
document.getElementById("heightmapping").onchange = heightmappingChanged;
document.getElementById("colormapping").onchange = colormappingChanged;
document.getElementById("graphxy").onchange = graphxyChanged;
document.getElementById("terrainEnabled").onchange = terrainChanged;
document.getElementById("buildingEnabled").onchange = buildingChanged;
document.getElementById("taperedEnabled").onchange = taperedEnabled;
document.getElementById("rawroadEnabled").onchange = rawroadEnabled;
document.getElementById("nodesEnabled").onchange = nodesEnabled;
document.getElementById("POIEnabled").onchange = POIEnabled;
document.getElementById('networkdrawEnabled').onchange = networkmappingChange;

document.getElementById("rd_light").onclick = refreshDataSourceTypeFun;
document.getElementById("rd_satellite").onclick = refreshDataSourceTypeFun;
document.getElementById("rd_dark").onclick = refreshDataSourceTypeFun;
document.getElementById("rd_streets").onclick = refreshDataSourceTypeFun;
document.getElementById("rd_outdoors").onclick = refreshDataSourceTypeFun;
document.getElementById("rd_terrain").onclick = refreshDataSourceTypeFun;

document.getElementById("rd_densitymap").onclick = refreshCfhSourceTypeFun;
document.getElementById("rd_labelmap").onclick = refreshCfhSourceTypeFun;

// Build 0003
nFilterType = 0
nSourceType = 0
nOldFilterType = 0
nOldSourceType = 0
nChartType = 3

csv_addr = ['https://raw.githubusercontent.com/thohan88/covid19-nor-data/master/data/03_covid_tests/national_tests.csv',
'https://raw.githubusercontent.com/thohan88/covid19-nor-data/master/data/01_infected/msis/municipality_and_district.csv',
'https://raw.githubusercontent.com/thohan88/covid19-nor-data/master/data/04_deaths/deaths_total_fhi.csv']

titles = ['Covid tests', 'Infected cases', 'Covid deaths']

charttypes = ['line','area','column','bar']

function drawHighCharts(x_data, y_data)
{
document.getElementById("container").innerHTML = "";
Highcharts.chart('container', {
chart: {
    type: charttypes[nChartType-1],
    zoomType: 'x'
},

title: {
    text: 'Covid Data'
},

subtitle: {
    text: 'Source: https://www.covid19data.no/'
},

yAxis: {
    min : 0,
    scrollbar: {
        enabled: true,
        showFull: true
    },
    title: {
        text: 'Number'
    }
},

xAxis: {
    categories: x_data,
    accessibility: {
        rangeDescription: 'In recent year'
    }
},

plotOptions: {
    series: {
        label: {
            connectorAllowed: false
        },
    },

    column: {
        stacking: 'normal',
        pointPadding : 0,
        groupPadding : 0,
        borderWidth: 0.5,
        // dataLabels: {
        //     enabled: true,
        //     color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white'
        // }
    }
},

series: [{
    name: titles[nSourceType],
    data: y_data,
}],

responsive: {
    rules: [{
        condition: {
            maxWidth: 500
        },
        chartOptions: {
            legend: {
                layout: 'horizontal',
                align: 'center',
                verticalAlign: 'bottom'
            }
        }
    }]
}

});
}
getmydata()
async function getmydata(){
console.log(123)
var response = await fetch(csv_addr[nSourceType])//('./national_tests.csv') //import the csv file
var datastring = await response.text() //import to text/string
var array = datastring.split('\n') // split string by '\n' (newline)
console.log(array)
var data_array = new Array()
var data_Numbers = new Array()
var data_DateTimes = new Array()
// Split and Parse the float data for fruit prices (exclude headers)
if(nSourceType == 0)
{
    // Tested
    for (var i = array.length-1; i>=0; i--){
        data_Numbers.push(parseFloat(array[i].split(',')[nFilterType + 1]))
        data_DateTimes.push(array[i].split(',')[0])
    }
}
else if(nSourceType == 1)
{
    // Infected
    if(nFilterType == 0)
    {
        if(array.length>0)
        {
            i_Date = 0
            i_Number = 11
            data_DateTimes.push(array[1].split(',')[i_Date])
            sum = parseInt(array[1].split(',')[i_Number])
            prev_sum = 0
            for (var i = 1; i < array.length; i++)
            {
                infectedRow = array[i].split(',')
                if(infectedRow[i_Date] == data_DateTimes[data_DateTimes.length-1])
                    sum += parseInt(infectedRow[i_Number])
                else
                {
                    if(data_Numbers.length == 0)
                        data_Numbers.push(sum)
                    else
                    {
                        data_Numbers.push(sum-prev_sum)
                    }
                    //console.log(infectedRow[i_Date],sum, prev_sum)
                    prev_sum = sum
                    sum = parseInt(infectedRow[i_Number])
                    data_DateTimes.push(infectedRow[i_Date])
                }
            }
            data_Numbers.push(sum) 
            data_Numbers = data_Numbers.slice(1, data_Numbers.length-1);// slice, delete first day infected data
            data_DateTimes = data_DateTimes.slice(1, data_DateTimes.length-1);
        }
    }
    else if(nFilterType == 1)
    {
        // sort before calucation
        // array.sort(function(a, b) {
        //     return new Date(a[0]) > new Date(b[0]);
        // });
        //
        if(array.length>0)
        {
            i_Date = 0
            i_Number = 11
            data_DateTimes.push(array[1].split(',')[i_Date])
            sum = parseInt(array[1].split(',')[i_Number])
            for (var i = 1; i < array.length; i++)
            {
                infectedRow = array[i].split(',')
                if(infectedRow[i_Date] == data_DateTimes[data_DateTimes.length-1])
                    sum += parseInt(infectedRow[i_Number])
                else
                {
                    data_Numbers.push(sum) 
                    sum = parseInt(infectedRow[i_Number])
                    data_DateTimes.push(infectedRow[i_Date])
                }
            }
            data_Numbers.push(sum) 
        }
    }
}
else if(nSourceType == 2)
{
    // Death
    if(nFilterType == 0)
    {
        for (var i = array.length-1; i>=1; i--)// the first day death is unknown
        {
            //data_array.push(new Array(array[i].split(',')[0],parseFloat(array[i].split(',')[1])))
            data_Numbers.push(parseFloat(parseFloat(array[i-1].split(',')[1]) - array[i].split(',')[1]))
            data_DateTimes.push(array[i].split(',')[0])
        }
    }
    else if(nFilterType == 1)
    {
        for (var i = array.length-1; i>=0; i--)
        {
            //data_array.push(new Array(array[i].split(',')[0],parseFloat(array[i].split(',')[1])))
            data_Numbers.push(parseFloat(array[i].split(',')[1]))
            data_DateTimes.push(array[i].split(',')[0])
        }
    }
}
console.log(data_array)
drawHighCharts(data_DateTimes,data_Numbers)
}

var panel_control_ob
panel_control_class=function(){
	var _self=this
	this.setup=function(){
		
		$("#panel_control").bind("click",function(){
			if($("#panel_control").hasClass("open")){
				$("#panel_control").removeClass("open").addClass("closed")	
				$(".overlay:not(#panel_control)").addClass("hidden")
                $(".map-overlay").addClass("hidden")
			}else{
				$("#panel_control").removeClass("closed").addClass("open")	
				$(".overlay:not(#panel_control)").removeClass("hidden")
                $(".map-overlay").removeClass("hidden")
			}
		})
	}
}
function create_panel_control_ob(){
	panel_control_ob=new panel_control_class()
	panel_control_ob.setup()
}
$(document).ready(function(){
	if($("#panel_control").length>0){
		create_panel_control_ob()
	}
})
</script>
</body>
</html>